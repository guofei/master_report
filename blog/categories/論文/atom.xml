<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 論文 | Master Report]]></title>
  <link href="http://guofei.github.com/master_report/blog/categories/論文/atom.xml" rel="self"/>
  <link href="http://guofei.github.com/master_report/"/>
  <updated>2012-10-29T14:19:40+09:00</updated>
  <id>http://guofei.github.com/master_report/</id>
  <author>
    <name><![CDATA[kaku]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OS研究会論文]]></title>
    <link href="http://guofei.github.com/master_report/blog/2012/10/29/osyan-jiu-hui-lun-wen/"/>
    <updated>2012-10-29T13:37:00+09:00</updated>
    <id>http://guofei.github.com/master_report/blog/2012/10/29/osyan-jiu-hui-lun-wen</id>
    <content type="html"><![CDATA[<h3>論文</h3>

<p>8ページ書いた。</p>

<p>FriendSocketのAPIの説面を追加した。暗号化の部分を少し追加した。</p>

<p>FriendSocket API
関数                    |説明
------------------------|------
frinedsocketio.connect()|サーバに接続する準備を行い、friendsocketclient オブジェクトを生成する
frinedsocketio.listen() |クライアントからの接続を待ち、friendsocketserver オブジェクトを生成する。 frinedsocketio.listen().friends で friendsocketserver オブジェクトの取得する</p>

<p>friendsocketclientオブジェクトのメッソド
関数  |説明
------------------------|------</p>

<p>friendsocketserverオブジェク       トのメッソド
+-------------------+------------+
|メソッド           |説明        |
+-------------------+------------+
|on("connection", f)|サーバに接続|
|                   |した時、    |
|                   |callbackの関|
|                   |数fを呼び出す|
|                   |。引数は    |
|                   |friendsocket|
|                   |オブジェクト|
|                   |である      |
+-------------------+------------+</p>

<p>動画協調アプリケーションとミドルウェアの部分が青沼さんが追加している</p>

<h3>FriendSocket APIのbugの修正</h3>

<p>クライアント側から同じappnameでサーバに接続すると、</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS研究会論文]]></title>
    <link href="http://guofei.github.com/master_report/blog/2012/10/23/osyan-jiu-hui-lun-wen/"/>
    <updated>2012-10-23T13:32:00+09:00</updated>
    <id>http://guofei.github.com/master_report/blog/2012/10/23/osyan-jiu-hui-lun-wen</id>
    <content type="html"><![CDATA[<h3>面接</h3>

<p>難しかった</p>

<p>日本でどのぐらい働きたいと聞かれて、５年ぐらいと答えると、５年間でせっかく人材として育ったのに、会社をやめるのはよくない</p>

<p>分散OSの話もあって、自分は分散OSが難しいですと話したら、どこが難しいと聞かれた。</p>

<h3>論文</h3>

<p>９章＝＞７章</p>

<p>元の画像は見づらいので、ソースコードを画像からテキストに変えた<br/>
実装をそれぞれの章に入れた</p>

<p>これからやるところ：<br/>
関連研究のところにBrowser DBusを追加<br/>
暗号化の部分を追加<br/>
動画アプリケーションの話</p>

<h3>暗号化</h3>

<p>鍵を読み込む時、パスフレーズの取得方法がわからない
```c
int PEM_write_RSAPrivateKey(FILE <em>fp, RSA </em>x,</p>

<pre><code>                        const EVP_CIPHER *enc, //暗号化アルゴリズム
                        unsigned char *kstr, int klen, //パスフレーズと長さ
                        pem_password_cb *cb, void *u); //callback
</code></pre>

<p>PEM_write_RSAPrivateKey(seckey, key, EVP_des_ede3_cbc(), "12345678", 8, NULL, NULL);
PEM_write_RSAPrivateKey(seckey, key, EVP_des_ede3_cbc(), NULL, 0, pass_cb, "My Private Key");
下のような鍵が生成される
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: DES-EDE3-CBC,81CB5FEC487EB67F
Ux3JFs0KSohF1GYs0rJ2VtQ+s5pjXJVsjPktIh9PzU+XLTAEOWdyWR/3fE5+hgZK
......
EUPfsZzEF2no/EMs6aCj5AdpJQu0PgHPU4oZmjTW0LU=
-----END RSA PRIVATE KEY-----
```</p>

<p><code>c
RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u);
</code></p>

<p>```c
int pass_cb(char <em>buf, int size, int rwflag, void </em>u);
{</p>

<pre><code>    int len;
    char *tmp;
    /* We'd probably do something else if 'rwflag' is 1 */
    printf("Enter pass phrase for \"%s\"\n", u);
    /* get pass phrase, length 'len' into 'tmp' */
    tmp = "hello";
    len = strlen(tmp);
    if (len &lt;= 0) return 0;
    /* if too long, truncate */
    if (len &gt; size) len = size;
    memcpy(buf, tmp, len);
    return len;
</code></pre>

<p>}
key = PEM_read_RSAPrivateKey(fp, NULL, pass_cb, "My Private Key");
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[コンピュータシステムシンポジウム論文]]></title>
    <link href="http://guofei.github.com/master_report/blog/2012/10/15/konpiyutasisutemusinpoziumulun-wen/"/>
    <updated>2012-10-15T02:08:00+09:00</updated>
    <id>http://guofei.github.com/master_report/blog/2012/10/15/konpiyutasisutemusinpoziumulun-wen</id>
    <content type="html"><![CDATA[<h3>論文</h3>

<p>７ページ書いた</p>

<ol>
<li>はじめに</li>
<li>現在の分散型ブラウザの通信機能と問題点</li>
<li>複数の IMS や SNS の利用</li>
<li>FriendSocket</li>
<li>グループ通信を実現するミドルウェア</li>
<li>協調動画視聴アプリケーション</li>
<li>実 装</li>
<li>関連研究</li>
<li>おわりに</li>
</ol>


<h3>Friendsocket API</h3>

<p>サーバ側にクリックすると、クライアントに一括送信するプログラム</p>

<p>クライアント
```js
var client = function() {</p>

<pre><code>var friend;
friend = friendsocketio.connect(name, password, peername, appname, host);
friend.on("connect", function(m) {
              friend.on("clicked", function(m) {
                            do_something(m);
                        });
          });
</code></pre>

<p>};
client();
```</p>

<p>サーバ
```js
var friend_list = new List();
var server = function() {</p>

<pre><code>var s;
s = friendsocketio.listen(name, password, appname, host);
s.friends.on("connection", function(friend) {
                      if(s.contactlist.contains(friend.name))
                          friend_list.push(friend);
             });
</code></pre>

<p>};
function sendMsg() {</p>

<pre><code>var friend, i, len;
for (i = 0, len = friend_list.length; i &lt; len; i++) {
    friend = friend_list[i];
    friend.emit("clicked", "clicked");
}
</code></pre>

<p>}
var el = document.getElementById("id");
el.addEventListener("Click", sendMsg, false);
server();
```</p>

<h3>ほかの人から聞かれた問題</h3>

<p>XMPPの通信路を利用するらな、XMPPの中央サーバを利用しなければならない。前に話した中央を利用しないことと矛盾になる？</p>

<p>分散型ブラウザの通信機能はxmppだけではなく、Skypeも利用できる。skypeを使うと、中央サーバを使わない。FriendSocketもskypeの利用を実装つもりだが、やる人足りない。xmppのほうは中央サーバを使うが、全部暗号化する。</p>

<h3>来週</h3>

<p>22日面接がある。</p>
]]></content>
  </entry>
  
</feed>
